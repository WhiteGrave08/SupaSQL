
import { CanonicalSchema, Table, Column, Relationship, MigrationStep } from '../types';

export const schemaToPostgresSQL = (schema: CanonicalSchema): string => {
  let sql = `-- Generated by SupaSQL (PostgreSQL Dialect)\n-- Generated: ${new Date().toLocaleString()}\n\n`;

  schema.tables.forEach((table) => {
    sql += `-- Table: ${table.name}\n`;
    if (table.description) sql += `-- Description: ${table.description}\n`;
    sql += `CREATE TABLE "${table.name}" (\n`;
    const columnDefinitions = table.columns.map((col) => {
      let def = `  "${col.name}" ${col.type.toUpperCase()}`;
      if (col.isPrimaryKey) def += ` PRIMARY KEY`;
      if (!col.isNullable) def += ` NOT NULL`;
      if (col.isUnique) def += ` UNIQUE`;
      if (col.defaultValue) def += ` DEFAULT ${col.defaultValue}`;
      return def;
    });
    sql += columnDefinitions.join(',\n');
    sql += `\n);\n\n`;
  });

  schema.relationships.forEach((rel) => {
    sql += `-- Relation: ${rel.fromTable} -> ${rel.toTable}\n`;
    sql += `ALTER TABLE "${rel.fromTable}" ADD CONSTRAINT "fk_${rel.fromTable}_${rel.fromColumn}" \n`;
    sql += `FOREIGN KEY ("${rel.fromColumn}") REFERENCES "${rel.toTable}" ("${rel.toColumn}")`;
    if (rel.onDelete) sql += ` ON DELETE ${rel.onDelete}`;
    if (rel.onUpdate) sql += ` ON UPDATE ${rel.onUpdate}`;
    sql += `;\n\n`;
  });

  return sql;
};

export const schemaToMySQL = (schema: CanonicalSchema): string => {
  let sql = `-- Generated by SupasQL (MySQL Dialect)\n-- Generated: ${new Date().toLocaleString()}\n\n`;

  schema.tables.forEach((table) => {
    sql += `CREATE TABLE \`${table.name}\` (\n`;
    const columnDefinitions = table.columns.map((col) => {
      let type = col.type.toUpperCase();
      if (type === 'UUID') type = 'VARCHAR(36)';
      if (type === 'TEXT') type = 'LONGTEXT';
      
      let def = `  \`${col.name}\` ${type}`;
      if (col.isPrimaryKey) def += ` PRIMARY KEY`;
      if (!col.isNullable) def += ` NOT NULL`;
      if (col.isUnique) def += ` UNIQUE`;
      if (col.defaultValue) def += ` DEFAULT ${col.defaultValue}`;
      return def;
    });
    sql += columnDefinitions.join(',\n');
    sql += `\n) ENGINE=InnoDB;\n\n`;
  });

  schema.relationships.forEach((rel) => {
    sql += `ALTER TABLE \`${rel.fromTable}\` ADD CONSTRAINT \`fk_${rel.fromTable}_${rel.fromColumn}\` \n`;
    sql += `FOREIGN KEY (\`${rel.fromColumn}\`) REFERENCES \`${rel.toTable}\` (\`${rel.toColumn}\`);\n\n`;
  });

  return sql;
};

export const schemaToSQLite = (schema: CanonicalSchema): string => {
  let sql = `-- Generated by SupaSQL (SQLite Dialect)\n-- Generated: ${new Date().toLocaleString()}\n\n`;

  schema.tables.forEach((table) => {
    sql += `CREATE TABLE "${table.name}" (\n`;
    const columnDefinitions = table.columns.map((col) => {
      let type = col.type.toUpperCase();
      if (type === 'UUID') type = 'TEXT';
      if (type === 'JSONB') type = 'TEXT';
      
      let def = `  "${col.name}" ${type}`;
      if (col.isPrimaryKey) def += ` PRIMARY KEY`;
      if (!col.isNullable) def += ` NOT NULL`;
      if (col.isUnique) def += ` UNIQUE`;
      if (col.defaultValue) def += ` DEFAULT ${col.defaultValue}`;
      return def;
    });
    sql += columnDefinitions.join(',\n');
    sql += `\n);\n\n`;
  });

  return sql;
};

export const schemaToPrisma = (schema: CanonicalSchema): string => {
  let prisma = `// Generated by SupaSQL\n// Generated: ${new Date().toLocaleString()}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\ngenerator client {\n  provider = "prisma-client-js"\n}\n\n`;

  schema.tables.forEach((table) => {
    prisma += `model ${table.name} {\n`;
    table.columns.forEach((col) => {
      let type = 'String';
      if (col.type === 'int') type = 'Int';
      if (col.type === 'bigint') type = 'BigInt';
      if (col.type === 'boolean') type = 'Boolean';
      if (col.type === 'timestamp') type = 'DateTime';
      if (col.type === 'decimal') type = 'Float';
      if (col.type === 'jsonb') type = 'Json';

      prisma += `  ${col.name} ${type}${col.isNullable ? '?' : ''}`;
      if (col.isPrimaryKey) prisma += ` @id`;
      if (col.isUnique) prisma += ` @unique`;
      if (col.defaultValue) prisma += ` @default(${col.defaultValue})`;
      prisma += `\n`;
    });
    
    // Relations in Prisma
    schema.relationships.forEach(rel => {
        if (rel.fromTable === table.name) {
            const toTable = schema.tables.find(t => t.name === rel.toTable);
            prisma += `  ${rel.toTable} ${rel.toTable} @relation(fields: [${rel.fromColumn}], references: [${rel.toColumn}])\n`;
        }
    });

    prisma += `}\n\n`;
  });

  return prisma;
};

export const calculateMigrationDiff = (prev: CanonicalSchema, next: CanonicalSchema): MigrationStep[] => {
  const steps: MigrationStep[] = [];

  // 1. Detect Removed Tables (Destructive)
  prev.tables.forEach(oldTable => {
    if (!next.tables.find(t => t.id === oldTable.id)) {
      steps.push({
        type: 'DROP_TABLE',
        sql: `DROP TABLE "${oldTable.name}" CASCADE; -- ⚠️ DESTRUCTIVE`,
        isDestructive: true
      });
    }
  });

  // 2. Detect Added or Modified Tables
  next.tables.forEach(newTable => {
    const oldTable = prev.tables.find(t => t.id === newTable.id);

    if (!oldTable) {
      // New Table
      let sql = `CREATE TABLE "${newTable.name}" (\n`;
      const cols = newTable.columns.map(c => `  "${c.name}" ${c.type.toUpperCase()}${c.isPrimaryKey ? ' PRIMARY KEY' : ''}`);
      sql += cols.join(',\n') + `\n);`;
      steps.push({ type: 'ADD_TABLE', sql, isDestructive: false });
    } else {
      // Rename Table
      if (newTable.name !== oldTable.name) {
        steps.push({
          type: 'ALTER_COLUMN',
          sql: `ALTER TABLE "${oldTable.name}" RENAME TO "${newTable.name}";`,
          isDestructive: false
        });
      }

      // Columns
      newTable.columns.forEach(newCol => {
        const oldCol = oldTable.columns.find(c => c.id === newCol.id);
        if (!oldCol) {
          steps.push({
            type: 'ADD_COLUMN',
            sql: `ALTER TABLE "${newTable.name}" ADD COLUMN "${newCol.name}" ${newCol.type.toUpperCase()}${!newCol.isNullable ? ' NOT NULL' : ''};`,
            isDestructive: false
          });
        } else if (newCol.type !== oldCol.type || newCol.name !== oldCol.name) {
             if (newCol.name !== oldCol.name) {
                steps.push({
                    type: 'ALTER_COLUMN',
                    sql: `ALTER TABLE "${newTable.name}" RENAME COLUMN "${oldCol.name}" TO "${newCol.name}";`,
                    isDestructive: false
                });
             }
             if (newCol.type !== oldCol.type) {
                steps.push({
                    type: 'ALTER_COLUMN',
                    sql: `ALTER TABLE "${newTable.name}" ALTER COLUMN "${newCol.name}" TYPE ${newCol.type.toUpperCase()}; -- ⚠️ Potential data loss if incompatible`,
                    isDestructive: true
                });
             }
        }
      });

      // Removed Columns
      oldTable.columns.forEach(oldCol => {
        if (!newTable.columns.find(c => c.id === oldCol.id)) {
          steps.push({
            type: 'ALTER_COLUMN',
            sql: `ALTER TABLE "${newTable.name}" DROP COLUMN "${oldCol.name}"; -- ⚠️ DESTRUCTIVE`,
            isDestructive: true
          });
        }
      });
    }
  });

  return steps;
};
